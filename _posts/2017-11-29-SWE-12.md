---
title: "SWE: A Comprehensive Review"
layout: post
---

Software Engineering with Dr. Glenn Downing is an aptly named class. Unlike other classes here at UT, it doesn't claim to pertain to a subfield of computer science. Rather, it claims to be about software engineering as a whole. It aims to provide a broad overview of the tools and techniques used in software engineering in the real world. It includes lectures about Python, SQL, and Regex syntax, readings, which are mostly about best practices, and hands-on experience creating a database website. Of course, there were also quizzes and tests over lecture material and readings. This review will address the effectiveness of various components of the course as well as how well they fit together.

## Lectures

In my opinion, the lectures are the most enjoyable part of the class. I enjoyed learning about Python trivia, as it shed light on the fundamental design choices that its authors made and helped me gain a deeper understanding and appreciation of the language. Questions about the syntax quirks covered in lecture tend to involve contrived code snippets that require close attention to detail to solve. While this may not seem very applicable in the real world, it is very much so because absolute clarity in understanding a language's syntax and semantics is extremely valuable when facing difficult debugging challenges, which arise fairly regularly in real-world programming.

The SQL and Regex lectures only seemed to scratch the surface in comparison to the level of detail we reached in Python. I'm not as familiar with SQL, but if I were in charge of expanding the scope of the Regex lectures, I would definitely cover greedy vs. non-greedy matching (as well as differences between Regex implementations!), alternations, the remaining quantifiers, non-capturing groups, nested (e.g. `abc ((\d\d)\d*)`) and quantified (e.g. `abc ((\d\d)+\d?)`) capturing groups, and backreferences. These topics, as well as Regex as a whole, are very potent for creating the types of challenging logic puzzles that are characteristic of Downing quizzes.

Students unfamiliar with Dr. Downing's lecture style—particularly the more shy ones—may be put off by his randomized roll call attendance that puts multiple people on the spot every lecture. Personally, I generally pay attention and follow along so I have no problem with the occasional participation he solicits. But if you tend to doze off or goof off during class, you may not enjoy the attention quite as much.

## Readings

The readings in this class cover a wide range of topics, including standard OOP principles, coding best practices, social commentary, and general college and career advice. To be honest, I didn't do any of the readings for this class. Granted, I was in Dr. Downing's other class a year ago and the readings were the same, but the bigger issue I have is that there is a high ratio of amount of reading to in-class application. They appeared on quizzes less consistently than in OOP when I took it, and I managed to do well enough on the reading questions on the first test anyway.

I appreciate the `StrategyPattern` series of lectures, which cover applications of the SOLID principles even though they don't mention the principles by name. But otherwise, the lectures didn't seem to be very concerned with the readings at all. In all other classes I have taken at UT, whenever there are readings for class, the lectures discuss the readings. This reinforces the material and caters to the learning habits of the greatest amount of students: those who learn by reading can do so, and those who learn by listening and watching can do so too.

## Projects

Out of all three major portions of the class, the projects ended up taking the most of my time and attention. I have a lot to say about them, so this section of the review will get a couple of subsections:

### Concept

The essential idea of the project is that each group creates a website that has information about different types of things that relate to each other, kind of like a really really small slice of Knowledge Graph. For example, a group might decide to build an IMDB clone that has information about films, actors, and genres. You are tasked with scraping a publicly available API for information you can use to populate your website.

While it is hailed as a dynamic website, I don't think it lives up to that label. Designing it as a single page application and fetching data using AJAX doesn't change the underlying reality that the nature of the data is that it doesn't change very often. You aren't hitting our API sources in realtime, instead querying as much as possible of their entire databases at once not more than five times throughout the semester. The website itself may be described as dynamic because you can filter, sort, and search the database, but the data itself is more or less completely static.

This leaves you with a website that is an inferior clone of an existing database website. Your website doesn't have the most updated information, it doesn't have the most robust user interface, and it can't handle as much traffic. (You'll run out of GCP credits.) Aside from being completely derivative and uninteresting, your project fundamentally relies on information that has been taken wholesale and without compensation from a source that has presumably worked very hard to collect it. This runs into anywhere from light grey areas to deep black areas with most of the databases freely available to us. I personally feel ethically conflicted about the work my group did while gathering data for our project, and I am not proud of the unoriginal work I published online.

If the idea is to create something I'm proud of enough to put on my resumé, my project for this class doesn't come remotely close. The two personal website projects that have made it onto my resumé are [JS-Y86](https://xsznix.github.io/js-y86/) and [Binaural](http://xsznix.github.io/binaural/). These two projects have passed the bar because both fill a niche that no previous website does: JS-Y86 provides an accessible simulator and web IDE for the Y86 educational programming language, and Binaural lets people generate binaural beats and noise with a DAW-like interface. (JS-Y86 is based on a previous work, but instead of being an inferior clone of it, it improves upon it in novel ways.)

Less restrictive project guidelines would pave the way for more original and memorable projects. A future student might come up with something fun that didn't exist before. This class could be the catalyst for the next [Pokemon Fusion](http://pokemon.alexonsager.net/), [FreeRice](http://freerice.com/#/english-vocabulary/1414), [Geoguessr](https://geoguessr.com/), or [Spurious Correlations](http://www.tylervigen.com/spurious-correlations). Each of these websites provides an interesting experience by looking at something from a different perspective and then sharing those new ideas with the world. That's a big part of what makes these successful websites memorable and differentiates them from the projects in this class. But in order for this class to push students to do something more exciting, it needs to encourage them to think outside the box, not inside it.

### Tools

If I were to create a real-world production-grade website that does the same thing as what my group did for our project, I would probably not use many of the tools we used for this class.

First of all, I wouldn't use React; it's overkill for a website of a mostly static nature, and it places an unnecessary bandwidth burden on the servers and forces visitors' computers to do more work than it ought to. I would prefer to do all of the templating on the server side (even though I'm a frontend guy, sometimes it's better to let the server do all the work) and only consider AJAX for features beyond the scope of the project such as search autocomplete. React itself is a great tool—it's just not the best solution in this case.

Second, I wouldn't use PlanItPoker. The website only seems 80% complete: it has all the functionality it needs to do the one thing it's supposed to do, but the UX has several rough edges. Additionally, the way the project specs tell us to use PIP seems like overkill. The smallest non-zero, non-coffee valid estimate we could make for a user story is one day, and we found that many of the "user stories" we created took less than a day of work, whach I would take to mean that we were creating too many of them. And personally, I think using Trello is sufficient for managing the tasks needed to complete a project. Perhaps someone could convince me that user stories are an important part of an agile process, but I wasn't won over by this class.

Third, I wouldn't use GCP. Several groups encountered issues with billing and many commented on the complex dashboard interface. My group also encountered issues with deploy times that were multiple magnitudes slower than competitors' offerings. AWS is just as capable and beats GCP in all the aspects someone in this class would care about. And there are many other hosting solutions that would be suitable for this project; even Firebase could be suitable for projects in this class.

Fourth, I am perplexed at why a requirement to use GitBook popped up after most of each technical report had already been written. By that point in a project, you should have committed to using a certain set of tools a long time ago and you shouldn't migrate over to new tools unless you have a substantial reason to do so.

Many of the other tools are useful and I would recommend them to future students. GitHub, Trello, Slack, and Postman are all great tools and they are very suitable for SWE projects.

Throughout the semester, many groups asked to use different tools than the ones prescribed in the specs. This goes to show that different groups make different design decisions for different projects, and I think it would be good to allow groups to have more freedom in which tools to use for databases, hosting providers, project management, and communication. Of course, that means that it wouldn't be as easy to assign grades based on how much a group used a tool, but I'd argue that that's not a good criterion anyway. Tools should be natural productivity aids in a process, and requiring more issues on Trello than is useful, for example, forces a group to put in extra work to meet the requirement for using the tool even though the extra work did nothing to aid productivity. If groups could choose all of their own tools, a more effective way to assess how well they used their tools would be to ask them to explain and defend their choice of tools in their technical report and explain how they end up using the tools they choose.

### Technical Report

The technical report also perplexes me. I find it extremely difficult to believe that one can write a meaningful 4500 word essay about a website as unoriginal as the ones we made this past semester. I personally could not bring myself to write a single word of the report because I didn't feel I could write anything substantial and genuine. For example, if I were honest about the use cases of our website, I would say that the only real use case is for a grader to give us a grade. For anything else you might want to visit our website to do, you really ought to use the real, established PhoneDB. But of course, I couldn't write that in our technical report.

I don't even think this class satisfies the requirements to carry a writing flag. First of all, if this course is "designed to give students experience with writing in an academic discipline," then I feel very bad for any academic discipline in which technical reports of the caliber seen in this class would be acceptable. Second, I disagree with the notion that the writing projects are "substantial." I've looked through some other groups' reports as well as my own group's, and a majority of each report is no more substantial than thin air. Groups fluffed up their reports by interspersing tangentially related information, repeating the same information several times throughout the report, adding several complete API responses (and counting them as like, a hundred words each), and using wordy sentence structure.

(Perhaps you could say that the weekly blog posts constitute a major portion of the writing component of the class. But those are, for the most part, even more fluffy than the technical reports, and we never revise or receive feedback on our blog posts.)

Compare this to *Language Endangerment and Rights*, a class I took over in the College of Liberal Arts for my linguistics degree. In that class, I spent most of the semester writing [this 13-page paper, which, in my opinion, does not contain nearly as much fluff as the technical report my group wrote for SWE](https://drive.google.com/open?id=0BwC7v898aeNpWVRRTXVYSnZxWU0). The writing process included multiple rounds of in-class presentations as well as multiple checkpoints with detailed feedback at every step. And in the end, I *still* didn't get a writing flag to show for it. It is absurd that that class does not carry a writing flag while this class does.

There would be much more interesting and substantial information to put in the technical report if, for example, students were allowed more flexibility in choosing the scope of their project and the tools they use for it. For example, if I had made JS-Y86 as part of this class, I could write about my motivation to help students learn Y86 in CS 429 without having to download virtualization software, find a Linux image, install it on a VM, and then install an arcane, buggy, and hard-to-compile simulator on it. I could also write about my use cases, which fit into a particular niche of being students of a computer architecture class that uses the one textbook that describes Y86. These use cases are not just fluff—JS-Y86 is used by students around the world at Ohio State University, University of Maryland, and even as far as the University of Bordeaux. Imagine explaining the challenges involved in polishing an assembler implementation in JavaScript and then extending it to provide IDE-like features such as realtime error checking in the gutter. That might actually be a technical report that might be worth reading from front to back.

I'm not sure why the technical report has such a high word count requirement when there's not that much that's interesting to talk about. Our websites aren't exactly novel, we don't have much choice in the overall structure of the website, and we also don't have much leeway in the tools we use. Nobody will want to visit the website because they would just use our primary data source, and our main motivation for making the website is to get a passing grade in SWE. So what's the report supposed to be about?

## Conclusion

The class's ambition to be a comprehensive overview of what it's like to be a software engineer is reflected in the way it encompasses so many different topics. It dips its toes into object-oriented programming, Python, web development, and testing as well as project management and agile processes. But that also means that some of the portions of the class don't relate to other portions. The readings felt disconnected from the lectures, which felt disconnected from the projects. It feels like you're taking three different classes because of how disjoint the material is at times.

Maybe I'm dreaming about a completely different class here, but perhaps it would be more effective to leave the OOP and Python part for other classes to cover and focus on the projects and technical report. After all, Dr. Downing does teach a class entitled *Object-Oriented Programming*, and there is a Python language class elsewhere in the department. I think it would be interesting to have lectures about the history of agile development, criteria for and examples of good user stories, demonstrations of browser automation, and overviews of various tools we might choose to use in our projects, which wouldn't be restricted to a very particular type of mostly static website. Instead of tests, the class could be entirely project-based, and technical reports could be uniquely personal insights into students' thought processes as they develop ideas that they come up with into websites that others might want to use. This sort of hands-on, ultra-creative application course is in very short supply here at UT, with Mobile News App Design and Longhorn Startup being the only course I can think of that cater to that niche. But I think it's exactly that kind of experience that would be the most valuable to someone who hasn't had previous internships and wants experience in what being a software engineer is like in the real world.

As it is, I would still Dr. Downing's *Software Engineering* to prospective students who want to get a taste of the real world. It's important to keep in mind, though, that the SWE class compared to working in industry is like watching shadows in Plato's Allegory of the Caves—it's simply not possible for anything in academia to accurately simulate working in industry. For that, you have to find a job. But with that caveat in mind, this class does make you learn how to make and run a website, which is very relevant and useful in today's internet-connected world. And it does expose you to common types of tools used for communication and project management in the software industry, which many people appreciate.

SWE is also good for students who need a writing flag but don't want to write like a liberal arts major. I honestly don't think the class deserves a writing flag, but that's not my decision to make. So people might as well take advantage of it.

I would not recommend SWE for those who have prior successful software internship experience at a competent company. If you've survived an internship and did well, chances are that you could learn anything in this class on the job without much difficulty, and you might be more interested in taking more specialized classes like multicore operating systems and computer vision.

Even though I have my gripes with the projects, I can still recognize that SWE is a very valuable experience for many students in UTCS. Whatever you're looking for in this class, chances are you'll find it somewhere simply due to the sheer breadth of material it covers. You'll have to do a lot of things for the projects, some of which seem like chores and some of which don't make sense, but honestly, that's really not any different from working in the real world.
